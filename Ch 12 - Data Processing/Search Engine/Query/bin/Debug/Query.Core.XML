<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Query.Core</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Query.Ast">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="P:Query.Enumerators.TokenPostingList.AtEnd">
<summary>
 If the enumerator as reached its final position. Reset by calling
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Query.Enumerators.TokenPostingList">
<summary>
 Generaliziation of a seq&lt;TokenPosition&gt; with an AdvanceTo method for
 bulk advancing. Note that this only performs a one-through traversal of
 the underlying sequence.

 Intentionally does not implement IEnumerable or IEnumerator because the
 casting required in F# makes it _very_ painful to deal with.
</summary>
</member>
<member name="M:Query.Enumerators.disjunctiveEnumerator(Query.Enumerators.TokenPostingList,Query.Enumerators.TokenPostingList)">
<summary>
 Disjunctive enumerator returning documents that are found in either list.
</summary>
</member>
<member name="M:Query.Enumerators.conjunctiveEnumerator(Query.Enumerators.TokenPostingList,Query.Enumerators.TokenPostingList)">
<summary>
 Combine two enumerators to return only documents found in both enumerators.
</summary>
</member>
<member name="M:Query.Enumerators.createExactPhraseEnumerator(Query.Enumerators.TokenPostingList[])">
<summary>
 Exact phrase enumerator. Returns all document positions where the given
 tokens occur in a specific order.

 This is done by finding all hits of the enumerators where the positions
 differ by one.
</summary>
</member>
<member name="T:Query.Enumerators">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Query.Lexer">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Query.Parser.token_to_string(Query.Parser.token)">
<summary>
 This function gets the name of a token as a string
</summary>
</member>
<member name="M:Query.Parser.prodIdxToNonTerminal(System.Int32)">
<summary>
 This function maps production indexes returned in syntax errors to strings representing the non terminal that would be produced by that production
</summary>
</member>
<member name="M:Query.Parser.tokenTagToTokenId(System.Int32)">
<summary>
 This function maps integers indexes to symbolic token ids
</summary>
</member>
<member name="M:Query.Parser.tagOfToken(Query.Parser.token)">
<summary>
 This function maps integers indexes to symbolic token ids
</summary>
</member>
<member name="T:Query.Parser">

</member>
</members>
</doc>
